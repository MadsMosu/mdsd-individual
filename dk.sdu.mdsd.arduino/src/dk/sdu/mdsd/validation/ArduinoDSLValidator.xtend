/*
 * generated by Xtext 2.17.0
 */
package dk.sdu.mdsd.validation

import org.eclipse.xtext.validation.Check
import dk.sdu.mdsd.arduinoDSL.Node
import java.util.HashSet
import dk.sdu.mdsd.arduinoDSL.ArduinoDSLPackage
import dk.sdu.mdsd.arduinoDSL.ComponentBody
import dk.sdu.mdsd.arduinoDSL.Component
import java.util.Arrays
import dk.sdu.mdsd.arduinoDSL.VariableDeclaration
import dk.sdu.mdsd.arduinoDSL.VariableReference
import dk.sdu.mdsd.arduinoDSL.VarRef
import dk.sdu.mdsd.arduinoDSL.BooleanLiteral
import org.eclipse.emf.ecore.EObject
import dk.sdu.mdsd.arduinoDSL.RuleBody
import dk.sdu.mdsd.arduinoDSL.ElseStatement
import dk.sdu.mdsd.arduinoDSL.ElseIfStatement
import dk.sdu.mdsd.arduinoDSL.IfStatement
import org.eclipse.xtext.EcoreUtil2
import dk.sdu.mdsd.arduinoDSL.NodeDefinition
import dk.sdu.mdsd.arduinoDSL.Program

/**
 * This class contains custom validation rules. 
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class ArduinoDSLValidator extends AbstractArduinoDSLValidator {

	

	@Check
	def void checkPinIsNotUsed(ComponentBody body) {

		val nodeComponents = body.eContainer.eContainer.eContents.toList;

		var analogInputPins = new HashSet<String>();
		var digitalPins = new HashSet<String>();
		var PWMPins = new HashSet<String>();

		for (component : nodeComponents) {
			val type = (component as Component).properties.type;
			val pin = (component as Component).properties.pin;
			val io = (component as Component).properties.io;

			if (type.equals('analog') && io.equals('input')) {
				if (analogInputPins.contains(type + pin)) {
					error("Pin is already in use", ArduinoDSLPackage.eINSTANCE.componentBody_Pin)
				} else {
					analogInputPins.add(type + pin)
				}
			}
			
			if (type.equals('digital')) {
				if (digitalPins.contains(type + pin)) {
					error("Pin is already in use", ArduinoDSLPackage.eINSTANCE.componentBody_Pin)
				} else {
					digitalPins.add(type + pin)
				}
			}
			
			if (type.equals('analog') && io.equals('output')) {
				if (PWMPins.contains(type + pin)) {
					error("Pin is already in use", ArduinoDSLPackage.eINSTANCE.componentBody_Pin)
				} else {
					PWMPins.add(type + pin)
				}
			}
		}
	}

	@Check
	def void checkDuplicateComponentNames(Node node) {
		
		var componentNames = new HashSet<String>();

		for (component : node.components) {
			val name = component.name;
			if (componentNames.contains(name)) {
				error("Duplicate component names", ArduinoDSLPackage.eINSTANCE.component_Name)
			} else
				componentNames.add(name)
		}
	}
	
	@Check
	def void checkDuplicateNodeNames(NodeDefinition node) {
		val names = newHashSet
		var allNodes = node.eContainer.eContents.toList.filter(NodeDefinition)
		
		for(n : allNodes) {
			if(names.contains(n.node.name)) {
				error('Node ' + n.node.name + ' already exists', ArduinoDSLPackage.eINSTANCE.node_Name)						
			} else {
				names.add(n)
			}
		}
	}
	
	@Check
	def void checkRateOnInputComponents(ComponentBody body) {
		if(body.io == "input" && body.rate === null) {
			error("Rate is required on input components", ArduinoDSLPackage.eINSTANCE.componentBody_Rate)
		}
	}
	
	@Check
	def void checkValidPin(ComponentBody body) {	
		var unoAnalogInputPins = new HashSet<Integer>(Arrays.asList(0, 1, 2, 3, 4, 5));
		var unoDigitalPins = new HashSet<Integer>(Arrays.asList(2, 3, 4, 5, 6, 11, 12, 13, 14, 15, 16, 17, 18, 19));
		var unoPwmPins = new HashSet<Integer>(Arrays.asList(5, 11, 12, 15, 16, 17))
		
		var nodeComponents = body.eContainer.eContainer.eContents.toList;

		for (component : nodeComponents) {
			var props = (component as Component).properties;
			if (props.io.equals('input') && props.type.equals('analog')) {
				if(!unoAnalogInputPins.contains(props.pin)) {
					error("This pin does not support analog input", ArduinoDSLPackage.eINSTANCE.componentBody_Pin)
				}
			}
			else if(props.type.equals('digital')) {
				if(!unoDigitalPins.contains(props.pin)) {
					error("This pin does not support digital input or output", ArduinoDSLPackage.eINSTANCE.componentBody_Pin)
				}
			}
			else if(props.io.equals('output') && props.type.equals('analog')) {
				if(!unoPwmPins.contains(props.pin)) {
					error("This pin does not support analog output", ArduinoDSLPackage.eINSTANCE.componentBody_Pin)
				}
			}	
		}		
	}
	
	@Check
	def void checkAssignedVariableRef(VariableDeclaration varDec) {
		if(varDec.value instanceof VarRef) {
			var type = varDec.type
			var refType = (varDec.value as VarRef).ref.type
			var ref = (varDec.value as VarRef).ref
			if(type.equals('int') || type.equals('double') || type.equals('float') || type.equals('long')) {
				if(refType.equals('bool')) {
						error(type + ' variable cannot be assigned to ' + refType + ' variable', ArduinoDSLPackage.eINSTANCE.variableDeclaration_Name)
				} else if(!refType.equals(type)){
					if(varDec.cast === null) {
						error(type + ' variable cannot be assigned to ' + refType + ' variable. Please use casting', ArduinoDSLPackage.eINSTANCE.variableDeclaration_Name)
					} else if(!varDec.cast.castType.equals(refType)) {
						error(type + ' cannot be cast to ' + ref.cast.castType, ArduinoDSLPackage.eINSTANCE.variableDeclaration_Cast)
					}
				}
			} else if(type.equals('bool')) {
				if(refType.equals('int') || refType.equals('double') || refType.equals('float') || refType.equals('long')) {
						error(type + ' variable cannot be assigned to ' + refType + ' variable', ArduinoDSLPackage.eINSTANCE.variableDeclaration_Name)
				}
			}
		}
	}
	
	@Check
	def void checkAssignedRefToRef(VarRef varRef) {
		if(varRef.value instanceof VarRef) {
			var type = varRef.ref.type
			var refType = (varRef.value as VarRef).ref.type
			var ref = varRef.ref
			if(type.equals('int') || type.equals('double') || type.equals('float') || type.equals('long')) {
				if(refType.equals('bool')) {
						error(type + ' variable cannot be assigned to ' + refType + ' variable', ArduinoDSLPackage.eINSTANCE.varRef_Ref)
				} else if(!refType.equals(type)){
					if(varRef.cast === null) {
						error(type + ' variable cannot be assigned to ' + refType + ' variable. Please use casting', ArduinoDSLPackage.eINSTANCE.variableDeclaration_Name)
					} else if(!varRef.cast.castType.equals(refType)) {
						error(type + ' cannot be cast to ' + ref.cast.castType, ArduinoDSLPackage.eINSTANCE.variableDeclaration_Cast)
					}
				}
			} else if(type.equals('bool')) {
				if(refType.equals('int') || refType.equals('double') || refType.equals('float') || refType.equals('long')) {
						error(type + ' variable cannot be assigned to ' + refType + ' variable', ArduinoDSLPackage.eINSTANCE.varRef_Ref)
				}
			}
		}
	}
	
	@Check
	def void checkBoolVariableIsBool(VariableDeclaration varDec) {
		var type = varDec.type
		if(type.equals('bool') && varDec.value !== null && !(varDec.value instanceof BooleanLiteral)) {
			error('Bool variable can only be assigned true or false value', ArduinoDSLPackage.eINSTANCE.variableDeclaration_Value)		
		}
	}
	
	@Check
	def void checkBoolRefIsBool(VarRef varRef) {
		var type = varRef.ref.type
		if(type.equals('bool') && varRef.value !== null && !(varRef.value instanceof BooleanLiteral)) {
			error('Bool reference can only be assigned true or false value', ArduinoDSLPackage.eINSTANCE.varRef_Ref)		
		}
	}
	
	@Check
	def void checkNumberVariableIsNumber(VariableDeclaration varDec) {
		var type = varDec.type
		if(type.equals('int') || type.equals('double') || type.equals('float') || type.equals('long')) {
			if(varDec.value instanceof BooleanLiteral) {
				error('Variable can only be assigned a numerical value', ArduinoDSLPackage.eINSTANCE.variableDeclaration_Value)
			}
		}
	}
	
	@Check
	def void checkNumberRefIsNumber(VarRef varRef) {
		var type = varRef.ref.type
		if(type.equals('int') || type.equals('double') || type.equals('float') || type.equals('long')) {
			if(varRef.value instanceof BooleanLiteral) {
				error('Reference can only be assigned a numerical value', ArduinoDSLPackage.eINSTANCE.variableDeclaration_Value)
			}
		}
	}
	
	@Check
	def void checkCastOnVariableDeclaration(VariableDeclaration varDec) {
		if(varDec.cast !== null) {
			var type = varDec.type
			var cast = varDec.cast.castType
			if(type.equals('int') || type.equals('double') || type.equals('float') || type.equals('long')) {
				if(cast.equals('bool')) {
						error(type + ' cannot be cast to ' + cast, ArduinoDSLPackage.eINSTANCE.variableDeclaration_Cast)
				}
			} else if(type.equals('bool')) {
				if(cast.equals('int') || cast.equals('double') || cast.equals('float') || cast.equals('long')) {
						error(type + ' cannot be cast to ' + cast, ArduinoDSLPackage.eINSTANCE.variableDeclaration_Cast)
				}
			}
		}
	}
	
	@Check
	def void checkCastOnVariableRef(VarRef varRef) {
		if(varRef.cast !== null) {
			var refType = varRef.ref.type
			var cast = varRef.cast.castType
			if(refType.equals('int') || refType.equals('double') || refType.equals('float') || refType.equals('long')) {
				if(cast.equals('bool')) {
						error(refType + ' cannot be cast to ' + cast, ArduinoDSLPackage.eINSTANCE.variableDeclaration_Cast)
				}
			} else if(refType.equals('bool')) {
				if(cast.equals('int') || cast.equals('double') || cast.equals('float') || cast.equals('long')) {
						error(refType + ' cannot be cast to ' + cast, ArduinoDSLPackage.eINSTANCE.variableDeclaration_Cast)
				}
			}
		}
	}
	
	@Check
	def void checkDuplicateVarName(VariableDeclaration varDec) {
		var variables = new HashSet<VariableDeclaration>()
		duplicateVarNameRecursive(varDec.eContainer, variables)
		variables.remove(varDec)
		for(stmt : variables) {
			if (stmt.name.equals(varDec.name)) {
				error('Variable ' + varDec.name + ' already exists', ArduinoDSLPackage.Literals.VARIABLE_DECLARATION__NAME)
			}
		}
	}
	
	def void duplicateVarNameRecursive(EObject x, HashSet<VariableDeclaration> varSet) {
		switch(x) {
			IfStatement: {
				for(stmt : x.statements.filter(VariableDeclaration)) {
					varSet.add(stmt)
				}
				duplicateVarNameRecursive(x.eContainer, varSet)
			}
			ElseIfStatement: {
				for(stmt : x.statements.filter(VariableDeclaration)) {
					varSet.add(stmt)
				}
				duplicateVarNameRecursive(x.eContainer, varSet)
			}
			ElseStatement: {
				for(stmt : x.statements.filter(VariableDeclaration)) {
					varSet.add(stmt)
				}
				duplicateVarNameRecursive(x.eContainer, varSet)
			}
			RuleBody: {
				for(stmt : x.statements.filter(VariableDeclaration)) {
					varSet.add(stmt)
				}
			}
			
		}
	}
}
